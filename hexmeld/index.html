<!--
/*
 * Hexmeld - A hex grid puzzle game
 * Copyright (c) 2025 Jason Hamilton
 *
 * Licensed under the BSD 3-Clause License.
 * See LICENSE file for details.
 */
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hexmeld - Hexagonal Puzzle Game</title>
    <link rel="icon" href="assets/hexmeld-icon.svg" type="image/svg+xml">
    <link rel="apple-touch-icon" href="assets/hexmeld-icon-180.png">
    <link rel="mask-icon" href="assets/hexmeld-icon.svg" color="#5b7fff">
    <meta name="theme-color" content="#0b1020">
    <link rel="manifest" href="assets/manifest.webmanifest">
    <style>
        :root{
            color-scheme:dark light;
            --bg-dark:#1a1f35;
            --panel-dark:#242b45;
            --text-dark:#e8ebf0;
            --muted-dark:#93a0b4;
            --bg-light:#f6f7fb;
            --panel-light:#ffffff;
            --text-light:#0f1422;
            --muted-light:#5b667a;
            --bg-high-contrast:#000000;
            --panel-high-contrast:#10131f;
            --text-high-contrast:#ffffff;
            --muted-high-contrast:#dce3ef;
            --primary:#5b7fff;
            --primary-high-contrast:#ffd400;
            --danger:#ff6b6b;
            --danger-high-contrast:#ff4d4d;
            --ghost-outline-dark:rgba(0,0,0,.35);
            --ghost-outline-light:rgba(15,20,34,.22);
            --ghost-outline-high-contrast:#ffffff;
            --overlay-bg:rgba(11,16,32,.85);
            --overlay-bg-high-contrast:rgba(0,0,0,.92);
            --button-text:#ffffff;
            --button-text-high-contrast:#000000;
            --gap:12px;
        }
        *,*::before,*::after{box-sizing:border-box}
        body{margin:0;min-height:100vh;display:flex;flex-direction:column;gap:var(--gap);padding:var(--gap);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial;--bg:var(--bg-dark);--panel:var(--panel-dark);--text:var(--text-dark);--muted:var(--muted-dark);--overlay-bg:var(--overlay-bg);--button-text:var(--button-text);--ghost-outline:var(--ghost-outline-dark);background:var(--bg);color:var(--text)}
        body.theme-dark{color-scheme:dark;--bg:var(--bg-dark);--panel:var(--panel-dark);--text:var(--text-dark);--muted:var(--muted-dark);--overlay-bg:var(--overlay-bg);--button-text:var(--button-text);--ghost-outline:var(--ghost-outline-dark)}
        body.theme-light{color-scheme:light;--bg:var(--bg-light);--panel:var(--panel-light);--text:var(--text-light);--muted:var(--muted-light);--overlay-bg:var(--overlay-bg);--button-text:var(--button-text);--ghost-outline:var(--ghost-outline-light)}
        body.theme-high-contrast{color-scheme:dark;--bg:var(--bg-high-contrast);--panel:var(--panel-high-contrast);--text:var(--text-high-contrast);--muted:var(--muted-high-contrast);--primary:var(--primary-high-contrast);--danger:var(--danger-high-contrast);--overlay-bg:var(--overlay-bg-high-contrast);--button-text:var(--button-text-high-contrast);--ghost-outline:var(--ghost-outline-high-contrast)}
        @media (prefers-color-scheme: light){body:not(.theme-dark){color-scheme:light;--bg:var(--bg-light);--panel:var(--panel-light);--text:var(--text-light);--muted:var(--muted-light)}}
        .panel{max-width:660px;width:100%;margin:0 auto;padding:12px;background:var(--panel);border-radius:10px;box-shadow:0 8px 24px rgba(0,0,0,.2);border:1px solid rgba(255,255,255,.06)}
        body.theme-high-contrast .panel{border:2px solid #ffffff;box-shadow:0 0 0 2px #000 inset,0 12px 28px rgba(0,0,0,.75)}

        .header{display:block}
        h1{font-size:1.4rem;margin:0}
        .meta{color:var(--muted)}
        .button{display:inline-block;padding:.5rem .75rem;border-radius:8px;border:0;font-weight:600;color:var(--button-text,#fff);background:var(--primary);cursor:pointer;transition:transform .12s ease,filter .12s ease}
        .button:hover{transform:translateY(-1px);filter:brightness(1.08)}
        .button:active{transform:translateY(0);filter:brightness(.95)}
        .button.ghost{background:transparent;outline:1px solid var(--ghost-outline);color:var(--text)}
        .button.danger{background:var(--danger)}
        .button:disabled{opacity:.5;cursor:not-allowed}
        body.theme-high-contrast .button{border:2px solid #ffffff;box-shadow:0 0 0 2px #000 inset,0 3px 0 rgba(255,255,255,.35)}
        body.theme-high-contrast .button.ghost{outline:2px solid #ffffff;border-width:2px}
        #canvas.shake{animation:shake .32s ease-in-out}
        @keyframes shake{
            0%,100%{transform:translateX(0)}
            20%{transform:translateX(-6px)}
            40%{transform:translateX(6px)}
            60%{transform:translateX(-4px)}
            80%{transform:translateX(4px)}
        }
        main{flex:1;display:flex;flex-direction:column;align-items:center;gap:var(--gap);width:100%}
        #gameContainer{display:flex;flex-direction:column;gap:var(--gap);align-items:center}
        #canvas{width:100%;height:auto;max-width:440px;border-radius:12px;background:#0001;border:1px solid #0004;box-shadow:0 12px 24px rgba(0,0,0,.25),inset 0 1px 2px rgba(255,255,255,.08),0 4px 8px rgba(0,0,0,.15)}
        body.theme-high-contrast #canvas{background:#05070f;border:2px solid #ffffff;box-shadow:0 0 0 2px #000 inset,0 16px 36px rgba(0,0,0,.9)}
        #preview{display:flex;gap:8px;align-items:center;font-weight:600}
        #preview span{color:var(--text)}
        .previewBall{
            position:relative;
            width:24px;
            height:24px;
            border-radius:50%;
            overflow:hidden;
            --preview-base:#ffffff;
            --preview-highlight:#ffffff;
            --preview-shadow:#d0d4db;
            --preview-rim-light:#ffffff;
            --preview-rim-shadow:#3a4155;
            background:radial-gradient(circle at 30% 30%, var(--preview-highlight), var(--preview-base) 58%, var(--preview-shadow));
            border:1px solid var(--preview-rim-shadow);
            box-shadow:inset 0 2px 3px var(--preview-rim-light), inset 0 -2px 3px var(--preview-rim-shadow), 0 1px 2px rgba(0,0,0,.35);
        }
        .previewBall::after{
            content:"";
            position:absolute;
            inset:0;
            border-radius:inherit;
            background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.9), rgba(255,255,255,0) 55%);
            transform:translate(-18%, -18%) scale(.6);
            pointer-events:none;
        }
        footer{margin-top:auto;text-align:center;font-size:.85rem;color:var(--muted);display:flex;flex-direction:column;gap:4px;align-items:center}
        footer a{color:inherit;text-decoration:none}
        footer a.button{color:var(--button-text,#fff)}
        footer a.button:hover{text-decoration:none}
        footer a:hover{text-decoration:underline}
        .source-link{font-size:.7rem;opacity:.72}
        #versionDisplay{margin-top:6px;font-size:.75rem}
        #gameOver{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:20px;background:var(--overlay-bg);backdrop-filter:blur(4px);z-index:20}
        #gameOver .panel{max-width:360px;text-align:center}
        #gameOver h2{margin:0 0 12px;font-size:1.5rem}
        #gameOver p{margin:6px 0;color:var(--muted)}
        #resetButton{margin-top:16px}
        #welcomeModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:20px;background:var(--overlay-bg);backdrop-filter:blur(4px);z-index:30}
        #welcomeModal .panel{max-width:360px;text-align:center}
        #welcomeModal h2{margin:0 0 12px;font-size:1.5rem}
        #welcomeModal p{margin:6px 0;color:var(--muted)}
        #welcomeDismiss{margin-top:16px}
        @media (max-width:768px){
            body{padding:var(--gap) 0 calc(var(--gap)*2);}
            .panel{border-radius:0;}
            #gameContainer{padding:10px 8px 16px;}
            #canvas{max-width:100%;border-radius:8px;}
        }
    </style>
</head>
<body>
    <header class="panel header" role="banner">
      <div style="display:flex;justify-content:space-between;align-items:center;width:100%;margin-bottom:8px">
        <h1 style="display:flex;gap:8px;align-items:center;margin:0">
          <img src="assets/hexmeld-icon.svg" alt="" width="24" height="24"> Hexmeld
        </h1>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="themeToggle" class="button ghost" aria-pressed="false" title="Toggle theme">Theme</button>
          <button id="undoButton" class="button ghost" title="Undo the last completed turn" disabled>Undo</button>
          <button id="playAgain" class="button" title="Start a new game (asks for confirmation if the board is active)">New Game</button>
        </div>
      </div>
      <div class="meta">Score <strong id="score">0</strong> · High <strong id="high">0</strong> · Turn <strong id="turn">0</strong> · Filled <strong id="filled">0</strong></div>
    </header>

    <main>
      <section class="panel" id="gameContainer">
        <div id="preview" class="meta" aria-live="polite">
          <span>Next:</span>
        </div>
        <canvas id="canvas"></canvas>
      </section>
    </main>

    <div id="gameOver">
      <div class="panel">
        <h2>Game Over</h2>
        <p>Your Score: <span id="finalScore">0</span> · Turn <span id="finalTurns">0</span></p>
        <p>High Score: <span id="highScore">0</span></p>
        <button id="resetButton" class="button" title="Start a new game (asks for confirmation if the board is active)">New Game</button>
      </div>
    </div>

    <div id="welcomeModal" role="dialog" aria-modal="true" aria-labelledby="welcomeTitle" aria-describedby="welcomeDescription" aria-hidden="true">
      <div class="panel">
        <h2 id="welcomeTitle">Welcome to Hexmeld</h2>
        <p id="welcomeDescription">Match colored clusters to score points. Place pieces wisely, then tap <strong>How to Play</strong> below for the full guide.</p>
        <button id="welcomeDismiss" class="button" type="button">Let&#39;s Go</button>
      </div>
    </div>

    <footer>
      <div>
        <a href="instructions.html" class="button" role="button">How to Play</a>
      </div>
      <div id="versionDisplay"></div>
      <div class="source-link">
        <a href="https://github.com/laydros/hexmeld" target="_blank" rel="noopener">View Source (AGPL-3.0)</a>
      </div>
    </footer>

    <script type="module">
        // Theme toggle: cycles through dark, light, and high contrast (persists)
        (()=>{
            const STORAGE_KEY='hexmeld-theme';
            const THEMES=['dark','light','high-contrast'];
            const THEME_LABELS={dark:'Dark',light:'Light','high-contrast':'High Contrast'};
            const themeClasses=THEMES.map(theme=>'theme-'+theme);
            const body=document.body;
            let currentTheme=THEMES[0];

            if(typeof localStorage!=='undefined'){
                try{
                    const stored=localStorage.getItem(STORAGE_KEY);
                    if(stored && THEMES.includes(stored)){
                        currentTheme=stored;
                    }else if(!stored){
                        localStorage.setItem(STORAGE_KEY,currentTheme);
                    }
                }catch(err){
                    console.warn('Hexmeld: unable to read theme preference',err);
                }
            }

            const updateButton=()=>{
                const button=document.getElementById('themeToggle');
                if(!button) return;
                const label=THEME_LABELS[currentTheme]||currentTheme;
                const ariaPressed=currentTheme==='light'?'true':currentTheme==='high-contrast'?'mixed':'false';
                button.setAttribute('aria-pressed',ariaPressed);
                button.setAttribute('aria-label',`Theme: ${label}. Activate to switch theme.`);
                button.setAttribute('title',`Switch theme (current: ${label})`);
                button.textContent=`Theme: ${label}`;
            };

            const scheduleRerender=()=>{
                const rerender=()=>{
                    if(typeof render==='function'){
                        render();
                    }
                    if(typeof updatePreviewDisplay==='function'){
                        updatePreviewDisplay();
                    }
                };
                if(typeof requestAnimationFrame==='function'){
                    requestAnimationFrame(rerender);
                }else{
                    setTimeout(rerender,0);
                }
            };

            const applyTheme=theme=>{
                if(!THEMES.includes(theme)){
                    theme=THEMES[0];
                }
                currentTheme=theme;
                body.classList.remove(...themeClasses);
                body.classList.add('theme-'+theme);
                updateButton();
                scheduleRerender();
            };

            applyTheme(currentTheme);

            const setupButton=()=>{
                const button=document.getElementById('themeToggle');
                if(!button) return;
                updateButton();
                button.addEventListener('click',()=>{
                    const index=THEMES.indexOf(currentTheme);
                    const nextTheme=THEMES[(index+1)%THEMES.length];
                    applyTheme(nextTheme);
                    if(typeof localStorage!=='undefined'){
                        try{
                            localStorage.setItem(STORAGE_KEY,nextTheme);
                        }catch(err){
                            console.warn('Hexmeld: unable to store theme preference',err);
                        }
                    }
                });
            };

            if(document.readyState==='loading'){
                document.addEventListener('DOMContentLoaded',setupButton);
            }else{
                setupButton();
            }
        })();

        // HUD refs
        const elScore=document.getElementById('score');
        const elHigh=document.getElementById('high');
        const elTurn=document.getElementById('turn');
        const elFilled=document.getElementById('filled');
        const btnUndo=document.getElementById('undoButton');
        const btnAgain=document.getElementById('playAgain');
        const resetButton=document.getElementById('resetButton');

        const welcomeModal=document.getElementById('welcomeModal');
        const welcomeDismiss=document.getElementById('welcomeDismiss');

        export function hudSet(score, high, turn, filled){
          if(elScore) elScore.textContent=score|0;
          if(elHigh) elHigh.textContent=high|0;
          if(elTurn) elTurn.textContent=turn|0;
          if(elFilled!==undefined && elFilled) elFilled.textContent=filled|0;
        }

        export function flashInvalid(el){
          if(!el) return;
          el.classList.remove('shake');
          void el.offsetWidth;
          el.classList.add('shake');
          setTimeout(()=>el.classList.remove('shake'), 360);
        }

        // Version check
        const GAME_VERSION = '2.0.3';
        console.log('Hexmeld version:', GAME_VERSION);
        document.getElementById('versionDisplay').textContent = `v${GAME_VERSION}`;

        if ('serviceWorker' in navigator) {
          navigator.serviceWorker.register('service-worker.js').catch((error) => {
            console.error('Hexmeld service worker registration failed:', error);
          });
        }

        const FIRST_VISIT_KEY='hexmeldFirstVisit';

        function hideWelcomeModal(){
          if(!welcomeModal) return;
          welcomeModal.style.display='none';
          welcomeModal.setAttribute('aria-hidden','true');
        }

        function showWelcomeModal(){
          if(!welcomeModal) return;
          welcomeModal.style.display='flex';
          welcomeModal.setAttribute('aria-hidden','false');
          if(welcomeDismiss){
            try{
              welcomeDismiss.focus({ preventScroll: true });
            }catch(_){
              welcomeDismiss.focus();
            }
          }
        }

        function setupWelcomeModal(){
          if(!welcomeDismiss || !welcomeModal) return;
          welcomeDismiss.addEventListener('click', hideWelcomeModal);
          welcomeModal.addEventListener('click', event => {
            if(event.target === welcomeModal){
              hideWelcomeModal();
            }
          });
          document.addEventListener('keydown', event => {
            if(event.key === 'Escape' && welcomeModal.style.display === 'flex'){
              hideWelcomeModal();
            }
          });
        }

        function showWelcomeIfNeeded(){
          if(typeof localStorage === 'undefined'){
            return;
          }

          try{
            if(localStorage.getItem(FIRST_VISIT_KEY)){
              return;
            }

            localStorage.setItem(FIRST_VISIT_KEY, '1');
            showWelcomeModal();
          }catch(err){
            console.warn('Hexmeld: unable to access welcome preference', err);
          }
        }

        setupWelcomeModal();

        if(document.readyState === 'loading'){
          document.addEventListener('DOMContentLoaded', showWelcomeIfNeeded);
        }else{
          showWelcomeIfNeeded();
        }

        const STORAGE_KEY = 'hexmeldGameState';
        let saveGameTimeout = null;

        // Constants
        const BOARD_RADIUS = 6;
        const COLOR_PALETTES = {
            default: [
                '#0000FF', // Blue
                '#FFFF00', // Yellow
                '#FF0000', // Red
                '#00FF00', // Green
                '#FFA500', // Orange
                '#800080', // Purple
                '#FFFFFF', // White
                '#00FFFF'  // Turquoise
            ],
            highContrast: [
                '#1F40FF', // Vivid blue
                '#FFE14A', // Bright yellow
                '#FF2E63', // Vivid red
                '#00D07A', // Bright green
                '#FF6B1A', // Bright orange
                '#B388FF', // Bright purple
                '#FFFFFF', // White
                '#00D5FF'  // Bright cyan
            ]
        };
        const MAX_COLOR_COUNT = Object.values(COLOR_PALETTES).reduce((max,palette)=>{
            const length=Array.isArray(palette)?palette.length:0;
            return length>max?length:max;
        },0);
        function clampColorCount(value){
            const max=Math.max(1,MAX_COLOR_COUNT);
            const num=Number.isFinite(value)?Math.floor(value):1;
            return Math.min(Math.max(num,1),max);
        }
        function getActivePalette(){
            if(typeof document!=='undefined' && document.body && document.body.classList.contains('theme-high-contrast')){
                return COLOR_PALETTES.highContrast;
            }
            return COLOR_PALETTES.default;
        }
        function getPaletteColor(index){
            const palette=getActivePalette();
            const length=palette.length||1;
            const normalized=((index%length)+length)%length;
            return palette[normalized]||'#FFFFFF';
        }

        function adjustColor(hex, amount) {
            if (!hex) return '#FFFFFF';
            let color = hex.replace('#', '');
            if (color.length === 3) {
                color = color.split('').map(c => c + c).join('');
            }

            const num = parseInt(color, 16);
            let r = (num >> 16) + amount;
            let g = ((num >> 8) & 0xff) + amount;
            let b = (num & 0xff) + amount;

            const clamp = (value) => Math.max(0, Math.min(255, value));
            r = clamp(r);
            g = clamp(g);
            b = clamp(b);

            const toHex = (value) => value.toString(16).padStart(2, '0');
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
        }

        // ====== GAME CONFIG (EDIT HERE FOR TESTING) ======
        const COLOR_CONFIG = {
            startingColors: 6,  // Start with first 6 colors (0-5)
            expansions: [
                { afterTurn: 20, addColors: 2 }  // After turn 20, add 2 more colors (indices 6-7)
                // Add more expansions like: { afterTurn: 50, addColors: 2 }
            ]
        };

        const SPAWN_CONFIG = {
            startingSpawnCount: 3,  // Start spawning 3 balls per turn
            increases: [
                { afterTurn: 40, spawnCount: 4 }, // After turn 40, spawn 4 balls per turn
                { afterTurn: 80, spawnCount: 5 }  // After turn 80, spawn 5 balls per turn
            ],
            boardThresholds: [
                { emptyCells: 10, spawnCount: 3 }, // When ≤10 empty cells, cap spawns at 3
                { emptyCells: 20, spawnCount: 4 }  // When ≤20 empty cells, cap spawns at 4
            ]
        };

        const SPAWN_INCREASES_SORTED = [...(SPAWN_CONFIG.increases || [])].sort((a, b) => a.afterTurn - b.afterTurn);
        const SPAWN_THRESHOLDS_SORTED = [...(SPAWN_CONFIG.boardThresholds || [])].sort((a, b) => a.emptyCells - b.emptyCells);
        const RNG_STATE_KEY = 'hexmeldRngState';

        // Combo multipliers: indexed by comboCount-1 (combo 1 = index 0)
        const COMBO_MULTIPLIERS = [1, 2, 3, 6, 10, 12, 20, 32];

        function generateSeed() {
            if (typeof crypto !== 'undefined' && typeof crypto.getRandomValues === 'function') {
                const buffer = new Uint32Array(1);
                crypto.getRandomValues(buffer);
                return buffer[0] >>> 0;
            }

            const now = Date.now() >>> 0;
            let entropy = now;
            if (typeof performance !== 'undefined' && typeof performance.now === 'function') {
                entropy ^= Math.floor(performance.now() * 1000) >>> 0;
            }

            entropy ^= entropy << 13;
            entropy ^= entropy >>> 17;
            entropy ^= entropy << 5;
            return entropy >>> 0;
        }

        function createDeterministicRng(seedValue) {
            let state = (Number.isFinite(seedValue) ? seedValue : 0) >>> 0;
            return {
                next() {
                    state = (state + 0x6D2B79F5) >>> 0;
                    let t = state;
                    t = Math.imul(t ^ (t >>> 15), t | 1);
                    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
                    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
                },
                getState() {
                    return state >>> 0;
                },
                setState(value) {
                    if (!Number.isFinite(value)) return;
                    state = value >>> 0;
                }
            };
        }

        let rng = createDeterministicRng(generateSeed());

        function getRngState() {
            return rng.getState();
        }

        function setRngState(newState) {
            if (!Number.isFinite(newState)) return;
            rng.setState(newState);
        }

        function reseedRng() {
            rng.setState(generateSeed());
        }

        function rngNext() {
            return rng.next();
        }

        function rngNextInt(maxExclusive) {
            if (!Number.isFinite(maxExclusive) || maxExclusive <= 0) {
                return 0;
            }
            const value = rngNext() * maxExclusive;
            return Math.min(Math.floor(value), maxExclusive - 1);
        }

        // ==================================================

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Game state
        let grid = new Map();
        let selectedCell = null;
        let selectedBallAnimation = null;
        let score = 0;
        let turnCount = 0;
        let comboCount = 0;
        let availableColorCount = clampColorCount(COLOR_CONFIG.startingColors);
        let preview = [];
        let lastTurnSnapshot = null;
        let gameOver = false;
        let highScore = 0;
        let inputLocked = false; // Prevent input during animations

        function persistGameState() {
            if (typeof localStorage === 'undefined') return;

            try {
                const gridData = Array.from(grid.entries()).map(([key, cell]) => [key, cell.color]);
                const storedScore = Number.isFinite(score) ? Math.max(0, Math.floor(score)) : 0;
                const storedTurn = Number.isFinite(turnCount) ? Math.max(0, Math.floor(turnCount)) : 0;
                const storedCombo = Number.isFinite(comboCount) ? Math.max(0, Math.floor(comboCount)) : 0;
                const storedAvailableColors = Number.isFinite(availableColorCount)
                    ? clampColorCount(availableColorCount)
                    : clampColorCount(COLOR_CONFIG.startingColors);

                const state = {
                    version: GAME_VERSION,
                    grid: gridData,
                    score: storedScore,
                    turnCount: storedTurn,
                    preview: clonePreviewArray(preview),
                    availableColorCount: storedAvailableColors,
                    gameOver,
                    highScore,
                    comboCount: storedCombo,
                    history: serializeSnapshot(lastTurnSnapshot),
                    [RNG_STATE_KEY]: getRngState()
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (err) {
                console.warn('Hexmeld: unable to save game state', err);
            }
        }

        function queueSaveGameState() {
            if (typeof localStorage === 'undefined') return;
            if (saveGameTimeout) return;

            saveGameTimeout = setTimeout(() => {
                saveGameTimeout = null;
                persistGameState();
            }, 120);
        }

        function saveGameStateImmediately() {
            if (typeof localStorage === 'undefined') return;
            if (saveGameTimeout) {
                clearTimeout(saveGameTimeout);
                saveGameTimeout = null;
            }
            persistGameState();
        }

        function clearSavedGameState() {
            if (typeof localStorage === 'undefined') return;
            if (saveGameTimeout) {
                clearTimeout(saveGameTimeout);
                saveGameTimeout = null;
            }
            try {
                localStorage.removeItem(STORAGE_KEY);
            } catch (err) {
                console.warn('Hexmeld: unable to clear game state', err);
            }
        }

        function normalizeColorIndex(value) {
            const len = MAX_COLOR_COUNT || 1;
            const num = Number.isFinite(value) ? Math.floor(value) : 0;
            return ((num % len) + len) % len;
        }

        function forEachStoredGridCell(entries, callback) {
            if (!Array.isArray(entries) || typeof callback !== 'function') return;

            for (const cellEntry of entries) {
                let key;
                let color;
                let q;
                let r;

                if (Array.isArray(cellEntry)) {
                    [key, color] = cellEntry;
                } else if (cellEntry && typeof cellEntry === 'object') {
                    if (typeof cellEntry.key === 'string') {
                        key = cellEntry.key;
                    }
                    if (Number.isFinite(cellEntry.q) && Number.isFinite(cellEntry.r)) {
                        q = cellEntry.q;
                        r = cellEntry.r;
                    }
                    if (Object.prototype.hasOwnProperty.call(cellEntry, 'color')) {
                        color = cellEntry.color;
                    }
                }

                if ((!Number.isFinite(q) || !Number.isFinite(r)) && typeof key === 'string') {
                    const parts = key.split(',').map(Number);
                    if (parts.length >= 2) {
                        [q, r] = parts;
                    }
                }

                if (!Number.isFinite(q) || !Number.isFinite(r) || !isValidHex(q, r)) {
                    continue;
                }

                callback({ q, r, color: normalizeColorIndex(color) });
            }
        }

        function clonePreviewArray(values) {
            if (!Array.isArray(values)) return [];
            return values.map(normalizeColorIndex);
        }

        function cloneGridState(sourceGrid) {
            const clone = new Map();
            if (!sourceGrid) return clone;

            for (const [key, cell] of sourceGrid.entries()) {
                if (typeof key !== 'string') continue;
                const [q, r] = key.split(',').map(Number);
                if (!Number.isFinite(q) || !Number.isFinite(r) || !isValidHex(q, r)) continue;
                const colorIndex = cell && Number.isFinite(cell.color) ? cell.color : 0;
                clone.set(`${q},${r}`, { color: normalizeColorIndex(colorIndex) });
            }

            return clone;
        }

        function createTurnSnapshot() {
            return {
                grid: cloneGridState(grid),
                score,
                turnCount,
                preview: clonePreviewArray(preview),
                availableColorCount,
                gameOver,
                comboCount,
                rngState: getRngState()
            };
        }

        function serializeSnapshot(snapshot) {
            if (!snapshot) return null;

            return {
                grid: Array.from(snapshot.grid.entries()).map(([key, cell]) => [key, cell.color]),
                score: Number.isFinite(snapshot.score) ? Math.max(0, Math.floor(snapshot.score)) : 0,
                turnCount: Number.isFinite(snapshot.turnCount) ? Math.max(0, Math.floor(snapshot.turnCount)) : 0,
                preview: clonePreviewArray(snapshot.preview),
                availableColorCount: Number.isFinite(snapshot.availableColorCount)
                    ? clampColorCount(snapshot.availableColorCount)
                    : clampColorCount(COLOR_CONFIG.startingColors),
                gameOver: !!snapshot.gameOver,
                comboCount: Number.isFinite(snapshot.comboCount) ? Math.max(0, Math.floor(snapshot.comboCount)) : 0,
                rngState: Number.isFinite(snapshot.rngState) ? snapshot.rngState >>> 0 : getRngState()
            };
        }

        function deserializeSnapshot(data) {
            if (!data) return null;

            const entry = Array.isArray(data) ? data[data.length - 1] : data;
            if (!entry || typeof entry !== 'object') return null;

            const snapshotGrid = new Map();
            forEachStoredGridCell(entry.grid, ({ q, r, color }) => {
                snapshotGrid.set(`${q},${r}`, { color });
            });

            return {
                grid: snapshotGrid,
                score: Number.isFinite(entry.score) ? Math.max(0, Math.floor(entry.score)) : 0,
                turnCount: Number.isFinite(entry.turnCount) ? Math.max(0, Math.floor(entry.turnCount)) : 0,
                preview: clonePreviewArray(entry.preview),
                availableColorCount: Number.isFinite(entry.availableColorCount)
                    ? clampColorCount(entry.availableColorCount)
                    : clampColorCount(COLOR_CONFIG.startingColors),
                gameOver: !!entry.gameOver,
                comboCount: Number.isFinite(entry.comboCount) ? Math.max(0, Math.floor(entry.comboCount)) : 0,
                rngState: Number.isFinite(entry.rngState) ? entry.rngState >>> 0 : getRngState()
            };
        }

        function updateUndoButtonState() {
            if (!btnUndo) return;
            const isDisabled = !lastTurnSnapshot;
            btnUndo.disabled = isDisabled;
            btnUndo.setAttribute('aria-disabled', isDisabled ? 'true' : 'false');
        }

        function pushTurnSnapshot() {
            lastTurnSnapshot = createTurnSnapshot();
            updateUndoButtonState();
            queueSaveGameState();
        }

        function loadUndoSnapshot(storedSnapshot) {
            lastTurnSnapshot = deserializeSnapshot(storedSnapshot);
            updateUndoButtonState();
        }

        // Animation state
        const animations = [];
        let animationFrameId = null;

        // Dynamic sizing
        let HEX_SIZE = 25;
        let hexWidth = HEX_SIZE * 2;
        let hexHeight = Math.sqrt(3) * HEX_SIZE;
        let isMobile = false;
        let hitRadius = HEX_SIZE * 0.5;

        // Calculate optimal canvas size and hex size
        function calculateCanvasSize() {
            // Detect mobile
            isMobile = window.innerWidth < 768;

            // Minimal canvas padding
            const canvasPadding = isMobile ? 20 : 40;

            // Available space for the entire canvas
            const availableWidth = window.innerWidth - canvasPadding;
            const headerAllowance = isMobile ? 220 : 260;
            const availableHeight = window.innerHeight - headerAllowance;

            // Board dimensions: how much space the hex board actually needs
            // Horizontal: furthest hex at q=±BOARD_RADIUS is at ±(1.5 * BOARD_RADIUS * HEX_SIZE)
            // Plus one hex radius on each side = total of (3 * BOARD_RADIUS + 2) * HEX_SIZE
            const boardHexWidth = 3 * BOARD_RADIUS + 2;

            // Vertical: approximately (sqrt(3) * (BOARD_RADIUS * 2 + 1)) * HEX_SIZE
            const boardHexHeight = Math.sqrt(3) * (BOARD_RADIUS * 2 + 1);

            // Calculate max hex size that fits with tight padding around board
            const boardPadding = isMobile ? 10 : 20; // Padding around the board within canvas
            const maxHexWidth = (availableWidth - boardPadding * 2) / boardHexWidth;
            const maxHexHeight = (availableHeight - boardPadding * 2) / boardHexHeight;

            const sizeCap = isMobile ? 25 : 18;
            HEX_SIZE = Math.min(maxHexWidth, maxHexHeight, sizeCap);
            // Ensure minimum size of 20px for mobile touch targets
            HEX_SIZE = Math.max(HEX_SIZE, isMobile ? 20 : 10);

            hexWidth = HEX_SIZE * 2;
            hexHeight = Math.sqrt(3) * HEX_SIZE;

            // Update hit radius based on device type
            hitRadius = isMobile ? HEX_SIZE * 0.6 : HEX_SIZE * 0.5;

            // Calculate tight canvas dimensions: just enough for board + padding
            const canvasWidth = boardHexWidth * HEX_SIZE + boardPadding * 2;
            const canvasHeight = boardHexHeight * HEX_SIZE + boardPadding * 2;

            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }

        // ====== ANIMATION FRAMEWORK ======

        // Easing functions
        function easeOutQuad(t) {
            return 1 - Math.pow(1 - t, 2);
        }

        function easeInQuad(t) {
            return t * t;
        }

        // Animation loop
        function animationLoop() {
            if (animations.length === 0) {
                animationFrameId = null;
                return;
            }

            const now = performance.now();

            // Update all animations
            for (let i = animations.length - 1; i >= 0; i--) {
                const anim = animations[i];
                const elapsed = now - anim.startTime;
                const progress = Math.min(1, elapsed / anim.duration);

                anim.update(progress);

                if (progress >= 1) {
                    if (anim.onComplete) {
                        anim.onComplete();
                    }
                    animations.splice(i, 1);
                }
            }

            render();

            if (animations.length > 0) {
                animationFrameId = requestAnimationFrame(animationLoop);
            } else {
                animationFrameId = null;
            }
        }

        // Add an animation
        function addAnimation(update, onComplete, duration) {
            animations.push({
                startTime: performance.now(),
                duration,
                update,
                onComplete
            });

            if (!animationFrameId) {
                animationFrameId = requestAnimationFrame(animationLoop);
            }
        }

        function stopSelectedBallHop() {
            if (selectedBallAnimation) {
                selectedBallAnimation = null;
            }
        }

        function startSelectedBallHop(cellKey) {
            if (!cellKey) return;
            const token = Symbol('selectedHop');
            selectedBallAnimation = { cellKey, offsetY: 0, scale: 1, token };
            queueSelectedBallHop(cellKey, token);
        }

        function queueSelectedBallHop(cellKey, token) {
            const hopHeight = HEX_SIZE * 0.22;
            const hopDuration = 420;

            addAnimation(
                (progress) => {
                    if (!selectedBallAnimation || selectedBallAnimation.cellKey !== cellKey || selectedBallAnimation.token !== token) {
                        return;
                    }
                    const hopProgress = Math.sin(progress * Math.PI);
                    selectedBallAnimation.offsetY = -hopHeight * hopProgress;
                    selectedBallAnimation.scale = 1 + 0.08 * hopProgress;
                },
                () => {
                    if (!selectedBallAnimation || selectedBallAnimation.cellKey !== cellKey || selectedBallAnimation.token !== token) {
                        return;
                    }
                    selectedBallAnimation.offsetY = 0;
                    selectedBallAnimation.scale = 1;
                    queueSelectedBallHop(cellKey, token);
                },
                hopDuration
            );
        }

        // Wait for all animations to complete
        function waitForAnimations(callback) {
            if (animations.length === 0) {
                callback();
            } else {
                const checkInterval = setInterval(() => {
                    if (animations.length === 0) {
                        clearInterval(checkInterval);
                        callback();
                    }
                }, 10);
            }
        }

        // ====== END ANIMATION FRAMEWORK ======

        // Animation overlays (drawn on top of normal rendering)
        let animatedBalls = []; // { q, r, color, scale, opacity }
        let blockedCell = null; // { q, r, flashProgress }
        let blockedSourceCell = null; // { q, r, flashProgress }
        let touchedHex = null; // For touch feedback
        let floatingScores = []; // { x, y, text, opacity, offsetY }

        function undoLastTurn() {
            if (!lastTurnSnapshot) return;

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            animations.length = 0;
            animatedBalls = [];
            floatingScores = [];
            blockedCell = null;
            blockedSourceCell = null;
            touchedHex = null;
            stopSelectedBallHop();
            selectedCell = null;
            selectedBallAnimation = null;
            inputLocked = false;

            const snapshot = lastTurnSnapshot;
            lastTurnSnapshot = null;

            grid = cloneGridState(snapshot.grid);
            score = Number.isFinite(snapshot.score) ? Math.max(0, Math.floor(snapshot.score)) : 0;
            turnCount = Number.isFinite(snapshot.turnCount) ? Math.max(0, Math.floor(snapshot.turnCount)) : 0;
            comboCount = Number.isFinite(snapshot.comboCount) ? Math.max(0, Math.floor(snapshot.comboCount)) : 0;
            availableColorCount = Number.isFinite(snapshot.availableColorCount)
                ? clampColorCount(snapshot.availableColorCount)
                : clampColorCount(COLOR_CONFIG.startingColors);
            const snapshotPreview = Array.isArray(snapshot.preview) ? clonePreviewArray(snapshot.preview) : [];
            preview = snapshotPreview;
            gameOver = !!snapshot.gameOver;

            if (Number.isFinite(snapshot.rngState)) {
                setRngState(snapshot.rngState);
            }

            hudSet(score, highScore, turnCount, grid.size);
            updatePreviewDisplay();

            if (gameOver) {
                document.getElementById('finalScore').textContent = score;
                document.getElementById('finalTurns').textContent = turnCount;
                document.getElementById('highScore').textContent = highScore;
                document.getElementById('gameOver').style.display = 'flex';
            } else {
                document.getElementById('gameOver').style.display = 'none';
            }

            updateUndoButtonState();
            render();
            queueSaveGameState();
        }

        // ====== END ANIMATION FRAMEWORK ======

        // Load high score from localStorage
        function loadHighScore() {
            const saved = localStorage.getItem('hexmeldHighScore');
            highScore = saved ? parseInt(saved, 10) : 0;
        }

        // Save high score to localStorage
        function saveHighScore() {
            localStorage.setItem('hexmeldHighScore', highScore.toString());
        }

        function loadSavedGame() {
            if (typeof localStorage === 'undefined') return false;

            let raw;
            try {
                raw = localStorage.getItem(STORAGE_KEY);
            } catch (err) {
                console.warn('Hexmeld: unable to read saved game state', err);
                return false;
            }

            if (!raw) return false;

            let data;
            try {
                data = JSON.parse(raw);
            } catch (err) {
                console.warn('Hexmeld: saved game state is corrupted', err);
                clearSavedGameState();
                return false;
            }

            if (!data || data.version !== GAME_VERSION) {
                clearSavedGameState();
                return false;
            }

            const storedRngState = data && Number.isFinite(data[RNG_STATE_KEY]) ? data[RNG_STATE_KEY] >>> 0 : null;
            if (Number.isFinite(storedRngState)) {
                setRngState(storedRngState);
            } else {
                reseedRng();
            }

            grid.clear();

            forEachStoredGridCell(data.grid, ({ q, r, color }) => {
                grid.set(`${q},${r}`, { color });
            });

            score = Number.isFinite(data.score) ? Math.max(0, Math.floor(data.score)) : 0;
            turnCount = Number.isFinite(data.turnCount) ? Math.max(0, Math.floor(data.turnCount)) : 0;
            comboCount = Number.isFinite(data.comboCount) ? Math.max(0, Math.floor(data.comboCount)) : 0;

            availableColorCount = clampColorCount(COLOR_CONFIG.startingColors);
            updateAvailableColors();
            const computedAvailableColors = availableColorCount;
            if (Number.isFinite(data.availableColorCount)) {
                const storedCount = clampColorCount(data.availableColorCount);
                availableColorCount = clampColorCount(Math.max(computedAvailableColors, storedCount));
            } else {
                availableColorCount = clampColorCount(computedAvailableColors);
            }

            if (Array.isArray(data.preview)) {
                preview = clonePreviewArray(data.preview);
            } else {
                preview = generatePreview();
            }

            gameOver = !!data.gameOver;
            highScore = Math.max(highScore, Number.isFinite(data.highScore) ? data.highScore : 0);

            loadUndoSnapshot(data.history);

            hudSet(score, highScore, turnCount, grid.size);
            updatePreviewDisplay();

            if (gameOver) {
                document.getElementById('finalScore').textContent = score;
                document.getElementById('finalTurns').textContent = turnCount;
                document.getElementById('highScore').textContent = highScore;
                document.getElementById('gameOver').style.display = 'flex';
            } else {
                document.getElementById('gameOver').style.display = 'none';
            }

            render();
            queueSaveGameState();
            return true;
        }

        // Initialize game
        function init(options = {}) {
            const forceNewGame = !!options.forceNew;

            calculateCanvasSize();

            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            animations.length = 0;
            animatedBalls = [];
            blockedCell = null;
            blockedSourceCell = null;
            touchedHex = null;
            floatingScores = [];
            inputLocked = false;
            stopSelectedBallHop();
            selectedCell = null;
            selectedBallAnimation = null;

            lastTurnSnapshot = null;
            updateUndoButtonState();

            // Load high score
            loadHighScore();

            if (!forceNewGame && loadSavedGame()) {
                return;
            }

            if (!forceNewGame) {
                clearSavedGameState();
            }

            reseedRng();

            grid.clear();
            score = 0;
            turnCount = 0;
            comboCount = 0;
            availableColorCount = clampColorCount(COLOR_CONFIG.startingColors);
            preview = generatePreview();
            updatePreviewDisplay();

            gameOver = false;
            document.getElementById('gameOver').style.display = 'none';

            // Place 5 starting balls
            const startBalls = 5;
            const emptyCells = getAllEmptyCells();
            for (let i = 0; i < startBalls; i++) {
                if (emptyCells.length > 0) {
                    const idx = rngNextInt(emptyCells.length);
                    const cell = emptyCells.splice(idx, 1)[0];
                    const color = rngNextInt(availableColorCount);
                    grid.set(cell, { color });
                }
            }

            syncHud();
            render();
            queueSaveGameState();
        }

        export function restartGame(){
            clearSavedGameState();
            init({ forceNew: true });
        }

        const RESTART_CONFIRM_MESSAGE = 'Start a new game? This will clear your current board progress.';

        function requestRestartGame(){
            const hasPieces = grid && grid.size > 0;

            if (gameOver || !hasPieces) {
                restartGame();
                return;
            }

            if (window.confirm(RESTART_CONFIRM_MESSAGE)) {
                restartGame();
            }
        }

        // Update available colors based on turn count
        function updateAvailableColors() {
            let newColorCount = COLOR_CONFIG.startingColors;
            for (const expansion of COLOR_CONFIG.expansions) {
                if (turnCount >= expansion.afterTurn) {
                    newColorCount += expansion.addColors;
                }
            }
            availableColorCount = clampColorCount(newColorCount);
        }

        // Get spawn count based on turn and remaining empty cells
        function getSpawnCountForState(turn, emptyCellsCount) {
            let spawnCount = SPAWN_CONFIG.startingSpawnCount;

            for (const increase of SPAWN_INCREASES_SORTED) {
                if (turn >= increase.afterTurn) {
                    spawnCount = increase.spawnCount;
                } else {
                    break;
                }
            }

            for (const threshold of SPAWN_THRESHOLDS_SORTED) {
                if (emptyCellsCount <= threshold.emptyCells) {
                    spawnCount = Math.min(spawnCount, threshold.spawnCount);
                }
            }

            return spawnCount;
        }

        // Generate preview of random balls (looks ahead to next turn's spawn count)
        function generatePreview() {
            const emptyCellsCount = getAllEmptyCells().length;
            const nextTurnSpawnCount = getSpawnCountForState(turnCount + 1, emptyCellsCount);
            const spawnTotal = Math.min(nextTurnSpawnCount, emptyCellsCount);
            const previewArray = [];
            for (let i = 0; i < spawnTotal; i++) {
                previewArray.push(rngNextInt(availableColorCount));
            }
            return previewArray;
        }

        // Update preview display
        function updatePreviewDisplay() {
            const previewContainer = document.getElementById('preview');
            if (!previewContainer) return;
            // Clear existing preview balls (except the "Next:" label)
            const existingBalls = previewContainer.querySelectorAll('.previewBall');
            existingBalls.forEach(ball => ball.remove());

            // Add new preview balls
            const palette = getActivePalette();
            const paletteLength = palette.length || 1;
            for (let i = 0; i < preview.length; i++) {
                const ball = document.createElement('div');
                const normalizedIndex = ((preview[i] % paletteLength) + paletteLength) % paletteLength;
                const baseColor = palette[normalizedIndex] || '#FFFFFF';
                const highlightColor = adjustColor(baseColor, 70);
                const shadowColor = adjustColor(baseColor, -80);
                const rimLight = adjustColor(baseColor, 95);
                const rimShadow = adjustColor(baseColor, -110);
                ball.className = 'previewBall';
                ball.style.setProperty('--preview-base', baseColor);
                ball.style.setProperty('--preview-highlight', highlightColor);
                ball.style.setProperty('--preview-shadow', shadowColor);
                ball.style.setProperty('--preview-rim-light', rimLight);
                ball.style.setProperty('--preview-rim-shadow', rimShadow);
                ball.style.background = `radial-gradient(circle at 30% 30%, ${highlightColor}, ${baseColor} 58%, ${shadowColor})`;
                ball.style.borderColor = rimShadow;
                ball.style.boxShadow = `inset 0 2px 3px ${rimLight}, inset 0 -2px 3px ${rimShadow}, 0 1px 2px rgba(0,0,0,0.35)`;
                previewContainer.appendChild(ball);
            }

            queueSaveGameState();
        }

        // Synchronize HUD with current game state
        function syncHud() {
            hudSet(score, highScore, turnCount, grid.size);
            queueSaveGameState();
        }

        // Get all valid hex cells for the board
        function getAllCells() {
            const cells = [];
            for (let q = -BOARD_RADIUS; q <= BOARD_RADIUS; q++) {
                for (let r = -BOARD_RADIUS; r <= BOARD_RADIUS; r++) {
                    const s = -q - r;
                    if (Math.abs(s) <= BOARD_RADIUS) {
                        cells.push(`${q},${r}`);
                    }
                }
            }
            return cells;
        }

        // Get all empty cells
        function getAllEmptyCells() {
            return getAllCells().filter(cell => !grid.has(cell));
        }

        // Convert offset coordinates to cube coordinates
        function offsetToCube(col, row) {
            const q = col;
            const r = row - (col - (col & 1)) / 2;
            return { q, r, s: -q - r };
        }

        // Convert cube coordinates to offset coordinates
        function cubeToOffset(q, r) {
            const col = q;
            const row = r + (q - (q & 1)) / 2;
            return { col, row };
        }

        // Get hex center position in pixels
        function hexToPixel(q, r) {
            const x = HEX_SIZE * (3/2 * q);
            const y = HEX_SIZE * (Math.sqrt(3)/2 * q + Math.sqrt(3) * r);
            return {
                x: x + canvas.width / 2,
                y: y + canvas.height / 2
            };
        }

        // Convert pixel to hex coordinates
        function pixelToHex(x, y) {
            x -= canvas.width / 2;
            y -= canvas.height / 2;

            const q = (2/3 * x) / HEX_SIZE;
            const r = (-1/3 * x + Math.sqrt(3)/3 * y) / HEX_SIZE;
            return hexRound(q, r);
        }

        // Round fractional hex coordinates to nearest hex
        function hexRound(q, r) {
            let s = -q - r;

            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);

            const q_diff = Math.abs(rq - q);
            const r_diff = Math.abs(rr - r);
            const s_diff = Math.abs(rs - s);

            if (q_diff > r_diff && q_diff > s_diff) {
                rq = -rr - rs;
            } else if (r_diff > s_diff) {
                rr = -rq - rs;
            }

            return { q: rq, r: rr };
        }

        // Check if hex is valid (within board)
        function isValidHex(q, r) {
            const s = -q - r;
            return Math.abs(q) <= BOARD_RADIUS &&
                   Math.abs(r) <= BOARD_RADIUS &&
                   Math.abs(s) <= BOARD_RADIUS;
        }

        // Get neighbors of a hex
        function getNeighbors(q, r) {
            const directions = [
                {q: 1, r: 0}, {q: 1, r: -1}, {q: 0, r: -1},
                {q: -1, r: 0}, {q: -1, r: 1}, {q: 0, r: 1}
            ];

            return directions
                .map(d => ({q: q + d.q, r: r + d.r}))
                .filter(hex => isValidHex(hex.q, hex.r))
                .map(hex => `${hex.q},${hex.r}`);
        }

        function getBoardVisualStyle() {
            const classes = (typeof document!=='undefined' && document.body) ? document.body.classList : null;
            if (classes && classes.contains('theme-high-contrast')) {
                return { fill: '#1f2937', stroke: '#ffffff', blockedFill: '#2c3a52' };
            }
            return { fill: '#999999', stroke: '#333333', blockedFill: '#bbbbbb' };
        }

        // Draw a hexagon
        function drawHex(centerX, centerY, fill = null, stroke = '#333') {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = centerX + HEX_SIZE * Math.cos(angle);
                const y = centerY + HEX_SIZE * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();

            if (fill) {
                // Add subtle radial gradient for depth
                const gradient = ctx.createRadialGradient(
                    centerX - HEX_SIZE * 0.3,
                    centerY - HEX_SIZE * 0.3,
                    0,
                    centerX,
                    centerY,
                    HEX_SIZE
                );
                gradient.addColorStop(0, adjustColor(fill, 15));
                gradient.addColorStop(1, adjustColor(fill, -10));
                ctx.fillStyle = gradient;
                ctx.fill();
            }

            ctx.strokeStyle = stroke;
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // Draw a ball
        function drawBall(centerX, centerY, colorIndex, isSelected = false, scale = 1, opacity = 1) {
            ctx.save();
            ctx.globalAlpha = opacity;

            const radius = HEX_SIZE * 0.7 * scale;
            const baseColor = getPaletteColor(colorIndex);
            const highlightColor = adjustColor(baseColor, 70);
            const shadowColor = adjustColor(baseColor, -60);

            const fillGradient = ctx.createRadialGradient(
                centerX - radius * 0.35,
                centerY - radius * 0.4,
                radius * 0.15,
                centerX,
                centerY,
                radius
            );
            fillGradient.addColorStop(0, highlightColor);
            fillGradient.addColorStop(0.55, baseColor);
            fillGradient.addColorStop(1, shadowColor);

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.fillStyle = fillGradient;
            ctx.fill();

            const rimGradient = ctx.createLinearGradient(centerX, centerY - radius, centerX, centerY + radius);
            rimGradient.addColorStop(0, 'rgba(255,255,255,0.35)');
            rimGradient.addColorStop(0.5, 'rgba(255,255,255,0.08)');
            rimGradient.addColorStop(1, 'rgba(0,0,0,0.35)');

            ctx.strokeStyle = rimGradient;
            ctx.lineWidth = Math.max(1, HEX_SIZE * 0.06 * scale);
            ctx.stroke();

            const glintRadius = radius * 0.38;
            const glintX = centerX - radius * 0.4;
            const glintY = centerY - radius * 0.45;
            const glintGradient = ctx.createRadialGradient(glintX, glintY, 0, glintX, glintY, glintRadius);
            glintGradient.addColorStop(0, 'rgba(255,255,255,0.9)');
            glintGradient.addColorStop(1, 'rgba(255,255,255,0)');

            ctx.beginPath();
            ctx.arc(glintX, glintY, glintRadius, 0, Math.PI * 2);
            ctx.fillStyle = glintGradient;
            ctx.fill();

            if (isSelected) {
                ctx.save();
                const outlineRadius = radius + Math.max(2, HEX_SIZE * 0.1 * scale);
                ctx.lineWidth = Math.max(2, HEX_SIZE * 0.12 * scale);
                ctx.strokeStyle = 'rgba(255,255,255,0.85)';
                ctx.shadowColor = 'rgba(0,0,0,0.45)';
                ctx.shadowBlur = HEX_SIZE * 0.35;
                ctx.beginPath();
                ctx.arc(centerX, centerY, outlineRadius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore();
        }

        // Draw touch feedback
        function drawTouchFeedback(q, r) {
            const pos = hexToPixel(q, r);
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i;
                const x = pos.x + HEX_SIZE * Math.cos(angle);
                const y = pos.y + HEX_SIZE * Math.sin(angle);
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }

        // Render the game
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (selectedCell && !grid.has(selectedCell)) {
                stopSelectedBallHop();
                selectedCell = null;
            }

            // Draw all hexes
            const allCells = getAllCells();
            const boardStyle = getBoardVisualStyle();
            const deferredSelectedBalls = [];
            for (const cellKey of allCells) {
                const [q, r] = cellKey.split(',').map(Number);
                const pos = hexToPixel(q, r);
                const isTouched = !!(touchedHex && touchedHex.q === q && touchedHex.r === r);
                let touchHandled = false;

                // Check if this is the blocked cell (show red flash)
                if (blockedCell && blockedCell.q === q && blockedCell.r === r) {
                    const alpha = 1 - blockedCell.flashProgress;
                    drawHex(pos.x, pos.y, boardStyle.blockedFill, `rgba(255, 0, 0, ${alpha})`);
                    // Draw extra thick red outline
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 3 * i;
                        const x = pos.x + HEX_SIZE * Math.cos(angle);
                        const y = pos.y + HEX_SIZE * Math.sin(angle);
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                } else {
                    drawHex(pos.x, pos.y, boardStyle.fill, boardStyle.stroke);
                }

                if (grid.has(cellKey)) {
                    const cell = grid.get(cellKey);
                    const isSelected = selectedCell === cellKey;
                    const isBlockedSource = !!(blockedSourceCell && blockedSourceCell.q === q && blockedSourceCell.r === r);
                    let drawY = pos.y;
                    let drawScale = 1;
                    if (isSelected && selectedBallAnimation && selectedBallAnimation.cellKey === cellKey) {
                        drawY += selectedBallAnimation.offsetY;
                        drawScale = selectedBallAnimation.scale;
                    }

                    if (isSelected) {
                        deferredSelectedBalls.push({
                            x: pos.x,
                            y: pos.y,
                            drawY,
                            color: cell.color,
                            scale: drawScale,
                            isBlockedSource,
                            drawTouch: isTouched,
                            q,
                            r
                        });
                        touchHandled = isTouched;
                    } else {
                        drawBall(pos.x, drawY, cell.color, false, drawScale);

                        if (isBlockedSource) {
                            const alpha = 1 - blockedSourceCell.flashProgress;
                            ctx.save();
                            ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                            ctx.lineWidth = 4;
                            ctx.beginPath();
                            ctx.arc(pos.x, pos.y, HEX_SIZE * 0.7, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.restore();
                        }

                        if (isTouched) {
                            drawTouchFeedback(q, r);
                            touchHandled = true;
                        }
                    }
                }

                // Draw touch feedback for empty cells or deferred selections
                if (isTouched && !touchHandled) {
                    drawTouchFeedback(q, r);
                }
            }

            for (const selected of deferredSelectedBalls) {
                drawBall(selected.x, selected.drawY, selected.color, true, selected.scale);

                if (selected.isBlockedSource) {
                    const alpha = 1 - blockedSourceCell.flashProgress;
                    ctx.save();
                    ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(selected.x, selected.y, HEX_SIZE * 0.7, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }

                if (selected.drawTouch) {
                    drawTouchFeedback(selected.q, selected.r);
                }
            }

            // Draw animated balls (on top of everything)
            for (const ball of animatedBalls) {
                const pos = hexToPixel(ball.q, ball.r);
                const offsetY = ball.offsetY || 0;
                drawBall(pos.x, pos.y + offsetY, ball.color, false, ball.scale, ball.opacity);
            }

            // Draw floating scores
            for (const floatingScore of floatingScores) {
                ctx.save();
                ctx.globalAlpha = floatingScore.opacity;
                ctx.font = `bold ${HEX_SIZE * 1.2}px system-ui, -apple-system, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Draw text shadow for better visibility
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = HEX_SIZE * 0.3;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                ctx.fillStyle = '#FFD700'; // Gold color
                ctx.fillText(floatingScore.text, floatingScore.x, floatingScore.y + floatingScore.offsetY);
                ctx.restore();
            }
        }

        function redrawBoard(){
            render();
        }

        // ====== ANIMATION FUNCTIONS ======

        // Animate ball movement along a path with hopping effect
        function animateMoveBallAlongPath(path, ball, onComplete) {
            if (!path || path.length < 2) {
                if (onComplete) onComplete();
                return;
            }

            inputLocked = true;

            const fromKey = path[0];
            const [fromQ, fromR] = fromKey.split(',').map(Number);

            // Create animated ball with additional properties for jumping
            const animBall = {
                q: fromQ,
                r: fromR,
                color: ball.color,
                scale: 1,
                opacity: 1,
                offsetY: 0  // Vertical offset for jumping effect
            };
            animatedBalls.push(animBall);

            // Remove ball from source in grid (it's now being animated)
            grid.delete(fromKey);

            let currentSegment = 0;

            function animateNextHop() {
                if (currentSegment >= path.length - 1) {
                    // Animation complete - place ball at final destination
                    const finalKey = path[path.length - 1];
                    animatedBalls = animatedBalls.filter(b => b !== animBall);
                    grid.set(finalKey, ball);
                    inputLocked = false;
                    queueSaveGameState();
                    if (onComplete) onComplete();
                    return;
                }

                const fromKey = path[currentSegment];
                const toKey = path[currentSegment + 1];
                const [fromQ, fromR] = fromKey.split(',').map(Number);
                const [toQ, toR] = toKey.split(',').map(Number);

                currentSegment++;

                const hopDuration = 150; // 150ms per hop

                addAnimation(
                    (progress) => {
                        const eased = easeOutQuad(progress);

                        // Move between cells
                        animBall.q = fromQ + (toQ - fromQ) * eased;
                        animBall.r = fromR + (toR - fromR) * eased;

                        // Create parabolic arc (jump effect)
                        // Peak of jump is at progress = 0.5
                        const jumpHeight = HEX_SIZE * 0.4;
                        const jumpProgress = Math.sin(progress * Math.PI);
                        animBall.offsetY = -jumpHeight * jumpProgress;

                        // Slight scale increase during jump
                        const scaleBoost = 1 + (0.15 * jumpProgress);
                        animBall.scale = scaleBoost;
                    },
                    () => {
                        // This hop is complete, start next one
                        animateNextHop();
                    },
                    hopDuration
                );
            }

            // Start the hopping animation
            animateNextHop();
        }

        // Animate blocked move (red flash on both source ball and destination cell)
        function animateBlockedMove(sourceKey, destKey) {
            const [destQ, destR] = destKey.split(',').map(Number);
            const [srcQ, srcR] = sourceKey.split(',').map(Number);
            blockedCell = { q: destQ, r: destR, flashProgress: 0 };
            blockedSourceCell = { q: srcQ, r: srcR, flashProgress: 0 };
            flashInvalid(canvas);

            addAnimation(
                (progress) => {
                    blockedCell.flashProgress = progress;
                    blockedSourceCell.flashProgress = progress;
                },
                () => {
                    blockedCell = null;
                    blockedSourceCell = null;
                },
                200 // 200ms duration
            );
        }

        // Animate spawning balls
        function animateSpawnBalls(cellsAndColors, onComplete) {
            inputLocked = true;

            // Create animated balls for each spawn
            const newAnimBalls = [];
            for (const { cellKey, color } of cellsAndColors) {
                const [q, r] = cellKey.split(',').map(Number);
                const animBall = {
                    q, r, color,
                    scale: 0,
                    opacity: 1
                };
                animatedBalls.push(animBall);
                newAnimBalls.push(animBall);
            }

            addAnimation(
                (progress) => {
                    const eased = easeOutQuad(progress);
                    for (const ball of newAnimBalls) {
                        ball.scale = eased;
                    }
                },
                () => {
                    // Animation complete - place balls in grid
                    for (const ball of newAnimBalls) {
                        const cellKey = `${Math.round(ball.q)},${Math.round(ball.r)}`;
                        grid.set(cellKey, { color: ball.color });
                    }
                    animatedBalls = animatedBalls.filter(b => !newAnimBalls.includes(b));
                    inputLocked = false;
                    queueSaveGameState();
                    if (onComplete) onComplete();
                },
                180 // 180ms duration
            );
        }

        // Animate removing balls (scale down + fade)
        function animateRemoveBalls(cellKeys, onComplete) {
            inputLocked = true;

            // Create animated balls for each cell to remove
            const removeAnimBalls = [];
            for (const cellKey of cellKeys) {
                const [q, r] = cellKey.split(',').map(Number);
                const cell = grid.get(cellKey);
                if (!cell) continue;

                if (cellKey === selectedCell) {
                    stopSelectedBallHop();
                    selectedCell = null;
                }

                const animBall = {
                    q, r,
                    color: cell.color,
                    scale: 1,
                    opacity: 1
                };
                animatedBalls.push(animBall);
                removeAnimBalls.push(animBall);

                // Remove from grid immediately so it doesn't render normally
                grid.delete(cellKey);
            }

            addAnimation(
                (progress) => {
                    const eased = easeInQuad(progress);
                    for (const ball of removeAnimBalls) {
                        ball.scale = 1 - eased;
                        ball.opacity = 1 - eased;
                    }
                },
                () => {
                    // Animation complete - remove animated balls
                    animatedBalls = animatedBalls.filter(b => !removeAnimBalls.includes(b));
                    inputLocked = false;
                    queueSaveGameState();
                    if (onComplete) onComplete();
                },
                220 // 220ms duration
            );
        }

        // Animate floating score text at the center of cleared group
        function animateFloatingScore(cellKeys, scoreValue, comboMultiplier = 1) {
            if (cellKeys.length === 0) return;

            // Calculate center of the group
            let sumX = 0, sumY = 0;
            for (const cellKey of cellKeys) {
                const [q, r] = cellKey.split(',').map(Number);
                const pos = hexToPixel(q, r);
                sumX += pos.x;
                sumY += pos.y;
            }
            const centerX = sumX / cellKeys.length;
            const centerY = sumY / cellKeys.length;

            // Create text with combo indicator if applicable
            let text = `+${scoreValue}`;
            if (comboMultiplier > 1) {
                text += ` (×${comboMultiplier.toFixed(1)})`;
            }

            const floatingScore = {
                x: centerX,
                y: centerY,
                text,
                opacity: 1,
                offsetY: 0
            };
            floatingScores.push(floatingScore);

            const duration = 800; // 800ms
            const riseDistance = HEX_SIZE * 3;

            addAnimation(
                (progress) => {
                    floatingScore.offsetY = -riseDistance * easeOutQuad(progress);
                    floatingScore.opacity = 1 - easeInQuad(progress);
                },
                () => {
                    // Remove from array when done
                    floatingScores = floatingScores.filter(s => s !== floatingScore);
                },
                duration
            );
        }

        // ====== END ANIMATION FUNCTIONS ======

        // BFS pathfinding - returns path as array of cell keys, or null if no path exists
        function findPath(startKey, endKey) {
            if (startKey === endKey) return [startKey];
            if (grid.has(endKey)) return null;

            const queue = [startKey];
            const visited = new Set([startKey]);
            const parent = new Map(); // Track parent for path reconstruction
            parent.set(startKey, null);

            while (queue.length > 0) {
                const current = queue.shift();
                const [q, r] = current.split(',').map(Number);
                const neighbors = getNeighbors(q, r);

                for (const neighbor of neighbors) {
                    if (neighbor === endKey) {
                        // Found the path! Reconstruct it
                        const path = [endKey];
                        let step = current;
                        while (step !== null) {
                            path.unshift(step);
                            step = parent.get(step);
                        }
                        return path;
                    }

                    if (!visited.has(neighbor) && !grid.has(neighbor)) {
                        visited.add(neighbor);
                        parent.set(neighbor, current);
                        queue.push(neighbor);
                    }
                }
            }

            return null;
        }

        // Flood fill to find connected group
        function findGroup(startKey) {
            if (!grid.has(startKey)) return [];

            const startColor = grid.get(startKey).color;
            const group = [];
            const visited = new Set();
            const queue = [startKey];

            while (queue.length > 0) {
                const current = queue.shift();
                if (visited.has(current)) continue;

                visited.add(current);
                if (!grid.has(current) || grid.get(current).color !== startColor) continue;

                group.push(current);

                const [q, r] = current.split(',').map(Number);
                const neighbors = getNeighbors(q, r);
                for (const neighbor of neighbors) {
                    if (!visited.has(neighbor)) {
                        queue.push(neighbor);
                    }
                }
            }

            return group;
        }

        // Calculate score for group size
        function calculateScore(groupSize) {
            // Triangular number progression: 6=6, 7=8, 8=11, 9=15, etc.
            // Formula: n + (n-6)*(n-5)/2
            if (groupSize < 6) return 0;
            return groupSize + (groupSize - 6) * (groupSize - 5) / 2;
        }

        // Remove groups with animation and callback
        // trackCombo: if true, increments comboCount for each group found and applies multiplier
        function checkAndRemoveGroups(cellsToCheck, callback, onGroupCleared = null, trackCombo = false) {
            let totalScore = 0;

            function checkIteration() {
                const checkedCells = new Set();
                let foundGroup = null;

                for (const cellKey of cellsToCheck) {
                    if (checkedCells.has(cellKey) || !grid.has(cellKey)) continue;

                    const group = findGroup(cellKey);
                    group.forEach(cell => checkedCells.add(cell));

                    if (group.length >= 6) {
                        foundGroup = group;
                        break; // Found a group, animate it
                    }
                }

                if (foundGroup) {
                    // Increment combo if tracking
                    if (trackCombo) {
                        comboCount++;
                    }

                    // Get combo multiplier from lookup table, default to last value if beyond array
                    const comboMultiplier = trackCombo
                        ? (COMBO_MULTIPLIERS[comboCount - 1] || COMBO_MULTIPLIERS[COMBO_MULTIPLIERS.length - 1])
                        : 1;

                    // Animate removal
                    const groupScore = calculateScore(foundGroup.length);
                    const finalScore = Math.floor(groupScore * comboMultiplier);
                    totalScore += finalScore;

                    // Notify caller of group cleared (for score animation)
                    if (onGroupCleared) {
                        onGroupCleared(foundGroup, finalScore, comboMultiplier);
                    }

                    animateRemoveBalls(foundGroup, () => {
                        // After animation, check for chain reactions
                        cellsToCheck = getAllCells();
                        checkIteration();
                    });
                } else {
                    // No more groups found
                    if (callback) callback(totalScore);
                }
            }

            checkIteration();
        }

        // Show game over screen
        function showGameOver() {
            gameOver = true;

            // Update high score if needed
            if (score > highScore) {
                highScore = score;
                saveHighScore();
            }
            hudSet(score, highScore, turnCount, grid.size);

            // Display scores
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalTurns').textContent = turnCount;
            document.getElementById('highScore').textContent = highScore;
            document.getElementById('gameOver').style.display = 'flex';

            saveGameStateImmediately();
        }

        // Spawn new balls with animation
        function spawnBalls(callback) {
            const emptyCells = getAllEmptyCells();
            const spawnCount = getSpawnCountForState(turnCount, emptyCells.length);

            if (spawnCount <= 0) {
                preview = generatePreview();
                updatePreviewDisplay();
                render();
                if (callback) callback();
                return;
            }

            if (preview.length > spawnCount) {
                preview = preview.slice(0, spawnCount);
                updatePreviewDisplay();
            } else if (preview.length < spawnCount) {
                const needed = spawnCount - preview.length;
                for (let i = 0; i < needed; i++) {
                    preview.push(rngNextInt(availableColorCount));
                }
                updatePreviewDisplay();
            }

            const ballsToSpawn = preview.length;

            if (emptyCells.length < ballsToSpawn) {
                // Game over - not enough space
                showGameOver();
                return;
            }

            const cellsAndColors = [];

            // Prepare spawn data
            for (let i = 0; i < ballsToSpawn; i++) {
                if (emptyCells.length === 0) break;

                const idx = rngNextInt(emptyCells.length);
                const cellKey = emptyCells.splice(idx, 1)[0];
                cellsAndColors.push({ cellKey, color: preview[i] });
            }

            // Animate spawning
            animateSpawnBalls(cellsAndColors, () => {
                // After spawn animation, check for groups with combo tracking enabled
                const spawnedCells = cellsAndColors.map(item => item.cellKey);

                checkAndRemoveGroups(spawnedCells, (scoreGained) => {
                    if (scoreGained > 0) {
                        score += scoreGained;
                        syncHud();
                    }

                    // Generate new preview
                    preview = generatePreview();
                    updatePreviewDisplay();

                    // Check if board is full
                    if (getAllEmptyCells().length === 0) {
                        showGameOver();
                    }

                    render();
                    if (callback) callback();
                }, (groupCells, finalScore, comboMultiplier) => {
                    // Show floating score for spawned ball groups with combo multiplier
                    animateFloatingScore(groupCells, finalScore, comboMultiplier);
                }, true); // Enable combo tracking for spawned balls
            });
        }

        // Handle input (used by both touch and click)
        function handleInput(x, y) {
            if (gameOver || inputLocked) return;

            const hex = pixelToHex(x, y);
            if (!isValidHex(hex.q, hex.r)) return;

            const cellKey = `${hex.q},${hex.r}`;

            // Show touch feedback
            touchedHex = { q: hex.q, r: hex.r };
            render();
            setTimeout(() => {
                touchedHex = null;
                render();
            }, 100);

            // If clicking on a ball
            if (grid.has(cellKey)) {
                selectedCell = cellKey;
                startSelectedBallHop(cellKey);
                render();
                return;
            }

            // If clicking empty cell with a ball selected
            if (selectedCell && !grid.has(cellKey)) {
                // Check if path exists and get the path
                const path = findPath(selectedCell, cellKey);
                if (path) {
                    const ball = grid.get(selectedCell);
                    stopSelectedBallHop();
                    selectedCell = null;

                    pushTurnSnapshot();

                    // Animate ball movement along the path
                    animateMoveBallAlongPath(path, ball, () => {
                        // Check for groups at destination with combo tracking enabled
                        checkAndRemoveGroups([cellKey], (scoreGained) => {
                            if (scoreGained > 0) {
                                // Group formed - add score (already includes combo multiplier), don't spawn
                                score += scoreGained;
                                syncHud();
                                render();
                            } else {
                                // No group - increment turn, reset combo, spawn new balls
                                turnCount++;
                                syncHud();
                                updateAvailableColors();
                                comboCount = 0;
                                spawnBalls();
                            }
                        }, (groupCells, finalScore, comboMultiplier) => {
                            // Show floating score with combo multiplier
                            animateFloatingScore(groupCells, finalScore, comboMultiplier);
                        }, true); // Enable combo tracking
                    });
                } else {
                    // Path blocked - show feedback
                    animateBlockedMove(selectedCell, cellKey);
                }
            }
        }

        // Get touch coordinates (accounting for canvas scaling)
        function getTouchCoords(touch) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        // Handle touch start
        function handleTouchStart(e) {
            e.preventDefault(); // Prevent ghost clicks and scrolling
            const touch = e.touches[0];
            const coords = getTouchCoords(touch);
            handleInput(coords.x, coords.y);
        }

        // Handle touch end
        function handleTouchEnd(e) {
            e.preventDefault();
        }

        // Handle click
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;
            handleInput(x, y);
        });

        // Touch event listeners
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                calculateCanvasSize();
                render();
            }, 250);
        });

        window.addEventListener('beforeunload', saveGameStateImmediately);
        window.addEventListener('pagehide', saveGameStateImmediately);
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                saveGameStateImmediately();
            }
        });

        // New game controls
        updateUndoButtonState();
        btnUndo&&btnUndo.addEventListener('click', undoLastTurn);
        btnAgain&&btnAgain.addEventListener('click', requestRestartGame);
        resetButton&&resetButton.addEventListener('click', requestRestartGame);

        // Start game
        init();
    </script>
</body>
</html>
